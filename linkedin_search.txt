import requests
import csv
from bs4 import BeautifulSoup
import os
import logging
from telegram import Bot
import asyncio
from dotenv import load_dotenv, find_dotenv

load_dotenv(find_dotenv())
TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")
CHAT_ID = os.environ.get("CHAT_ID")

# Configurar o logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.addHandler(logging.FileHandler('log.txt'))
log_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
file_handler = logging.FileHandler('log.txt')
file_handler.setFormatter(log_formatter)
logger.addHandler(file_handler)


async def send_telegram_message(message):
    bot = Bot(TELEGRAM_TOKEN)
    await bot.send_message(chat_id=CHAT_ID, text=message)


def check_existing_jobs(title, company):
    with open('jobs.csv', 'r', newline='', encoding='utf-8') as existing_csv:
        reader = csv.reader(existing_csv)
        if any((existing_job[0] == title and existing_job[1] == company) for existing_job in reader):
            return True
    return False


def extract_job_information(job_element):
    title = job_element.find('h3', class_='base-search-card__title').text.strip()
    company = job_element.find('h4', class_='base-search-card__subtitle').text.strip()
    location = job_element.find('span', class_='job-search-card__location').text.strip()

    date_element = job_element.find('time', class_='job-search-card__listdate--new')
    date_created = date_element['datetime'] if date_element else ''

    url_element = job_element.find('a', class_='base-card__full-link')
    url = url_element['href'] if url_element else ''

    return title, company, location, date_created, url


def scrape_linkedin_jobs(url, names_exception, names_remove):
    page_number = 0  # Número inicial da página
    total_results = 0  # Número total de resultados

    while True:
        try:
            response = requests.get(f'{url}={page_number}')
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            logger.error(f"Erro ao fazer a requisição HTTP: {e}")
            break

        soup = BeautifulSoup(response.text, 'html.parser')
        results_container = soup.find('ul', class_='jobs-search__results-list')

        if not results_container:
            break

        job_elements = results_container.find_all('div', class_='base-card')

        for job_element in job_elements:
            title, company, location, date_created, url = extract_job_information(job_element)

            if any(exp in title for exp in names_exception) and not any(name in title for name in names_remove):
                if not check_existing_jobs(title, company):
                    job_info = [title, company, location, date_created, url]
                    with open('jobs.csv', 'a', newline='', encoding='utf-8') as csv_file:
                        writer = csv.writer(csv_file)
                        writer.writerow(job_info)
                        total_results += 1

                    message = f"Título: {title}\nEmpresa: {company}\nLocalização: {location}\nData de Criação: {date_created}\nLink: {url}"
                    asyncio.run(send_telegram_message(message))

        page_number += 25

    logger.info(f"Foram extraídos {total_results} empregos e salvos no arquivo jobs.csv.")



if __name__ == '__main__':
    if not os.path.exists('jobs.csv'):
        with open('jobs.csv', 'w', newline='', encoding='utf-8') as csv_file:
            writer = csv.writer(csv_file)

    names_remove = {'Business', 'Cybersecurity', 'Technical', 'Salesforce', 'Data', 'Fullstack'}

    url_job_mapping = {
        'https://www.linkedin.com/jobs/search/?currentJobId=3540986533&f_TPR=r86400&f_WT=2&geoId=101174742&keywords=systems%20analyst&location=Canada&refresh=true&start':
            {'names_list': ['Systems', 'Support', 'Analyst']},
        'https://www.linkedin.com/jobs/search?keywords=Outsystems&location=Canada&locationId=&geoId=101174742&f_TPR=r604800&position=1&pageNum=0':
            {'names_list': ['OutSystems', 'Outsystems']},
        'https://www.linkedin.com/jobs/search/?currentJobId=3625344482&f_TPR=r604800&geoId=103366113&keywords=systems%20analyst&location=Vancouver%2C%20British%20Columbia%2C%20Canada&refresh=true&start':
            {'names_list': ['Systems', 'Support', 'Analyst']},
        'https://www.linkedin.com/jobs/search?keywords=Python%20Developer&location=Canada&locationId=&geoId=101174742&f_TPR=r86400&f_WT=2&position=1&pageNum=0&start':
            {'names_list': ['Pyhton', 'Backend']},
        'https://www.linkedin.com/jobs/search?keywords=Outsystems&location=United%20States&locationId=&geoId=103644278&f_TPR=r604800&f_WT=2&position=1&pageNum=0&start':
            {'names_list': ['OutSystems', 'Outsystems']},
        'https://www.linkedin.com/jobs/search/?currentJobId=3681086405&f_TPR=r86400&f_WT=2&geoId=92000000&keywords=outsystems&location=Worldwide&refresh=true&position=5&pageNum=0':
            {'names_list': ['OutSystems', 'Outsystems']},
    }

    for url, config in url_job_mapping.items():
        scrape_linkedin_jobs(url, config['names_list'], names_remove)